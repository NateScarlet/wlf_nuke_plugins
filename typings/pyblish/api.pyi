# -*- coding=UTF-8 -*-
# This typing file was generated by typing_from_help.py
"""
pyblish.api - Expose common functionality
"""

import six
import typing

"""
Use this in plugins, integrations and extensions of Pyblish.
This part of the library is what will change the least and
attempt to maintain backwards- and forwards-compatibility.

This way, we as developers are free to refactor the library
without breaking any of your tools.

.. note:: Contributors, don't use this in any other module internal
    to Pyblish or a cyclic dependency will be created. This is only
    to be used by end-users of the library and from
    integrations/extensions of Pyblish.
"""
class Action:
    """
    User-supplied interactive action

    Subclass this class and append to Plugin.actions in order
    to provide your users with optional, context sensitive
    functionality.

    Attributes:
        label: Optional label to display in place of class name.
        active: Whether or not to allow execution of action.
        on: When to enable this action; available options are:
            - "all": Always available (default).
            - "notProcessed": The plug-in has not yet been processed
            - "processed": The plug-in has been processed
            - "succeeded": The plug-in has been processed, and succeeded
            - "failed": The plug-in has been processed, and failed
            - "warning": The plug-in has been processed, and had a warning
            - "failedOrWarning": The plug-in has been processed, and failed or
              had a warning
        icon: Name, relative path or absolute path to image for
            use as an icon of this action. For relative paths,
            the current working directory of the host is used and
            names represent icons available via Awesome Icons.
            fortawesome.github.io/Font-Awesome/icons/
    """

    __error__: ... = None
    """
    """

    __type__: ...
    """
    'action'
    """

    active: ...
    """
    True
    """

    icon: ... = None
    """
    """

    label: ... = None
    """
    """

    log: ...
    """
    <logging.Logger object>
    """

    def __repr__(self):
        """
        """
        ...

    def __str__(self):
        """
        """
        ...

    id: six.binary_type
    """
    """

    def process(self):
        """
        """
        ...

    ...

Asset = Instance

class Collector(Plugin):
    """
    Parse a given working scene for available Instances
    """

    __contextEnabled__: ...
    """
    False
    """

    __instanceEnabled__: ...
    """
    False
    """

    __pre11__: ...
    """
    False
    """

    log: ...
    """
    <logging.Logger object>
    """

    order: ... = 0
    """
    """

    ...

class ConformError(PyblishError):
    """
    Baseclass for conforming errors
    """

    ...

Conformer = Integrator

class Context(AbstractEntity):
    """
    Maintain a collection of Instances
    """

    def __contains__(self, key):
        """
        Support both Instance objects and `id` strings

        Example:
            >>> context = Context()
            >>> instance = context.create_instance("MyInstance")
            >>> instance.id in context
            True
            >>> instance in context
            True
            >>> "NotExists" in context
            False
        """
        ...

    def __getitem__(self, item):
        """
        Enable support for dict-like getting of children by id

        Example:
            >>> context = Context()
            >>> instance = context.create_instance("MyInstance")
            >>> assert context[instance.id].name == "MyInstance"
            >>> assert context[0].name == "MyInstance"
        """
        ...

    def __init__(self, name='Context', parent=None):
        """
        """
        ...

    def add(self, *args, **kwargs):
        """
        """
        ...

    def create_asset(self, *args, **kwargs):
        """
        """
        ...

    def create_instance(self, name, **kwargs):
        """
        Convenience method of the following.

        >>> ctx = Context()
        >>> inst = Instance("name", parent=ctx)

        Example:
            >>> ctx = Context()
            >>> inst = ctx.create_instance(name="Name")
        """
        ...

    def get(self, key, default=None):
        """
        Enable support for dict-like getting of children by id

        Example
            >>> context = Context()
            >>> instance = context.create_instance("MyInstance")
            >>> assert context.get(instance.id).name == "MyInstance"
        """
        ...

    ...

class ContextPlugin(Plugin):
    __contextEnabled__: ...
    """
    True
    """

    __instanceEnabled__: ...
    """
    False
    """

    __pre11__: ...
    """
    False
    """

    log: ...
    """
    <logging.Logger object>
    """



    def process(self, context):
        """
        Primary processing method

        Arguments:
            context (Context): Context with which to process
        """
        ...

    ...

class ExtractionError(PyblishError):
    """
    Baseclass for extraction errors
    """

    ...

class Extractor(Plugin):
    """
    Physically separate Instance from Host into corresponding resources
    """

    __contextEnabled__: ...
    """
    False
    """

    __instanceEnabled__: ...
    """
    False
    """

    __pre11__: ...
    """
    False
    """

    log: ...
    """
    <logging.Logger object>
    """

    order: ... = 2
    """
    """

    ...

class Instance(AbstractEntity):
    """
    An in-memory representation of one or more files

    Examples include rigs, models.

    Arguments:
        name (str): Name of instance, typically used during
            extraction as name of resulting files.
        parent (AbstractEntity): Optional parent. This is
            supplied automatically when creating instances with
            :class:`Context.create_instance()`.
    """

    log: ...
    """
    <logging.Logger object>
    """

    def __eq__(self, other):
        """
        """
        ...

    def __init__(self, name, parent=None):
        """
        """
        ...

    def __ne__(self, other):
        """
        """
        ...

    def __repr__(self):
        """
        """
        ...

    def __str__(self):
        """
        """
        ...

    ...

class InstancePlugin(Plugin):
    __contextEnabled__: ...
    """
    False
    """

    __instanceEnabled__: ...
    """
    True
    """

    __pre11__: ...
    """
    False
    """

    log: ...
    """
    <logging.Logger object>
    """

    id: six.binary_type
    """
    """

    def process(self, instance):
        """
        Primary processing method

        Arguments:
            instance (Instance): Instance with which to process
        """
        ...

    ...

class Integrator(Plugin):
    """
    Integrates publishes into a pipeline
    """

    __contextEnabled__: ...
    """
    False
    """

    __instanceEnabled__: ...
    """
    False
    """

    __pre11__: ...
    """
    False
    """

    log: ...
    """
    <logging.Logger object>
    """

    order: ... = 3
    """
    """

    ...

class NoInstancesError(Exception):
    """
    Raised if no instances could be found
    """

    __weakref__: ...
    """
    list of weak references to the object (if defined)
    """

    ...

class Plugin:
    """
    Base-class for plugins

    Attributes:
        hosts: Optionally limit a plug-in to one or more hosts
        families: Optionally limit a plug-in to one or more families
        label: Printed name of plug-in
        active: Whether or not to use plug-in during processing
        version: Optional version for forwards-compatibility.
            Pyblish is (currently not) using the version to allow
            for plug-ins incompatible with a particular running
            instance of Pyblish to co-exist alongside compatible
            versions.
        order: Order in which this plug-in is processed. This is
            used internally to control which plug-ins are processed
            before another so as to allow plug-ins to communicate
            with each other. E.g. one plug-in may provide critical
            information to another and so must be allowed to be
            processed first.
        optional: Whether or not plug-in can be skipped by the user.
        requires: Which version of Pyblish is required by this plug-in.
            Plug-ins requiring a version newer than the current version
            will not be loaded. 1.0.8 was when :attr:`Plugin.requires`
            was first introduced.
        actions: Actions associated to this plug-in
        id: Unique ID as str
        match: Family matching algorithm - Intersection, Subset or Exact
            Intersection -> set(a).intersection(b)
            Subset       -> set(a).issubset(b)
            Exact        -> a == b
    """

    __contextEnabled__: ...
    """
    False
    """

    __instanceEnabled__: ...
    """
    False
    """

    __pre11__: ...
    """
    False
    """

    actions: ...
    """
    []
    """

    active: ...
    """
    True
    """

    families: ...
    """
    ['*']
    """

    hosts: ...
    """
    ['*']
    """

    label: ... = None
    """
    """

    log: ...
    """
    <logging.Logger object>
    """

    match: ... = 1
    """
    """

    optional: ...
    """
    False
    """

    order: ... = -1
    """
    """

    requires: ...
    """
    'pyblish>=1'
    """

    targets: ...
    """
    ['default']
    """

    def __repr__(self):
        """
        """
        ...

    def __str__(self):
        """
        """
        ...

    id: six.binary_type
    """
    """

    def process(self):
        """
        Primary processing method

        This method is called whenever your plug-in is invoked
        and is injected with object relative to it's signature.

        E.g. process(self, context, instance) will have the current
        context and instance injected into it at run-time.

        Available objects:
            - context
            - instance
            - user
            - time

        Raises:
            Any error
        """
        ...

    def repair(self):
        """
        DEPRECATED
        """
        ...

    ...

class PyblishError(Exception):
    """
    Baseclass for all Pyblish exceptions
    """

    __weakref__: ...
    """
    list of weak references to the object (if defined)
    """

    ...

class SelectionError(PyblishError):
    """
    Baseclass for selection errors
    """

    ...

Selector = Collector

class Separator(Action):
    __error__: ... = None
    """
    """

    __type__: ...
    """
    'separator'
    """

    ...

class ValidationError(PyblishError):
    """
    Baseclass for validation errors
    """

    ...

class Validator(Plugin):
    """
    Validate/check/test individual instance for correctness.
    """

    __contextEnabled__: ...
    """
    False
    """

    __instanceEnabled__: ...
    """
    False
    """

    __pre11__: ...
    """
    False
    """

    log: ...
    """
    <logging.Logger object>
    """

    order: ... = 1
    """
    """

    ...

def Category(label):
    """
    """
    ...


__default_test = default_test

def __init__():
    """
    Initialise Pyblish

    This function registered default services,
    hosts and tests. It is idempotent and thread-safe.
    """
    ...


__main_package_path = main_package_path()

__time = time()

def current_host():
    """
    Return host last registered thru `register_host()`

    When running Pyblish from within a host, this function determines
    which host is running and returns the equivalent keyword.

    Example:
        >> # Running within Autodesk Maya
        >> current_host()
        "maya"
        >> # Running within Sidefx Houdini
        >> current_host()
        "houdini"
        >> # Running from an unknown software
        >> current_host()
        "unknown"
    """
    ...


def current_target():
    """
    """
    ...


def deregister_all(*args, **kwargs):
    """
    """
    ...


def deregister_all_callbacks():
    """
    Deregisters all callback
    """
    ...


def deregister_all_discovery_filters():
    """
    Deregisters all plugin filters
    """
    ...


def deregister_all_hosts():
    """
    """
    ...


def deregister_all_paths():
    """
    Mainly used in tests
    """
    ...


def deregister_all_plugins():
    """
    De-register all plug-ins
    """
    ...


def deregister_all_services(*args, **kwargs):
    """
    De-register all existing services
    """
    ...


def deregister_all_targets():
    """
    """
    ...


def deregister_callback(signal, callback):
    """
    Deregister a callback

    Arguments:
        signal (string): Name of signal to deregister the callback with.
        callback (func): Function to execute when a signal is emitted.

    Raises:
        KeyError on missing signal
        ValueError on missing callback
    """
    ...


def deregister_discovery_filter(callback):
    """
    Deregister a plugin filter

    Arguments:
        callback (func): filtering function.

    Raises:
        ValueError on missing callback
    """
    ...


def deregister_gui(package):
    """
    """
    ...


def deregister_host(host, quiet=False):
    """
    Remove an already registered host

    Arguments:
        host (str): Name of host
        quiet (bool): Whether to raise an exception
            when attempting to remove a host that is
            not already registered.
    """
    ...


def deregister_plugin(plugin):
    """
    De-register an existing plug-in

    Arguments:
        plugin (Plugin): Existing plug-in to de-register
    """
    ...


def deregister_plugin_path(path):
    """
    Remove a pyblish._registered_paths path

    Raises:
        ValueError if `path` isn't registered
    """
    ...


def deregister_service(*args, **kwargs):
    """
    De-register an existing service by name

    Arguments:
        name (str): Name of service
    """
    ...


def deregister_target(target, quiet=False):
    """
    Remove an already registered target

    Arguments:
        target (str): Name of target
        quiet (bool): Whether to raise an exception
            when attempting to remove a target that is
            not already registered.
    """
    ...


def deregister_test():
    """
    Restore default test
    """
    ...


def discover(type=None, regex=None, paths=None):
    """
    Find and return available plug-ins

    This function looks for files within paths registered via
    :func:`register_plugin_path` and those added to `PYBLISHPLUGINPATH`.

    It determines *type* - :class:`Selector`, :class:`Validator`,
    :class:`Extractor` or :class:`Conform` - based on whether it
    matches it's corresponding regular expression; e.g.
    "$validator_*^" for plug-ins of type Validator.

    Arguments:
        type (str, optional): !DEPRECATED! Only return plugins of
            specified type. E.g. validators, extractors. In None is specified,
            return all plugins. Available options are "selectors", validators",
            "extractors", "conformers", "collectors" and "integrators".
        regex (str, optional): Limit results to those matching `regex`.
            Matching is done on classes, as opposed to
            filenames, due to a file possibly hosting
            multiple plugins.
        paths (list, optional): Paths to discover plug-ins from.
            If no paths are provided, all paths are searched.
    """
    ...


def emit(signal, **kwargs):
    """
    Trigger registered callbacks

    Keyword arguments are passed from caller to callee.

    Arguments:
        signal (string): Name of signal emitted

    Example:
        >>> import sys
        >>> from . import plugin
        >>> plugin.register_callback(
        ...   "mysignal", lambda data: sys.stdout.write(str(data)))
        ...
        >>> emit("mysignal", data={"something": "cool"})
        {'something': 'cool'}
    """
    ...


def environment_paths():
    """
    Return paths added via environment variable
    """
    ...


def format_filename(*args, **kwargs):
    """
    """
    ...


def instances_by_plugin(instances, plugin):
    """
    Return compatible instances `instances` to plugin `plugin`

    Return instances as they correspond to a plug-in, given
    an algorithm. The algorithm is determined by the `Plugin.match`

    When `match == Subset`, families of an instance must be a
    subset of families supported by a plug-in.

    Arguments:
        instances (list): List of instances
        plugin (Plugin): Plugin with which to compare against

    Returns:
        List of compatible instances

    Invariant:
        Order of remaining plug-ins must remain the same
    """
    ...


def log(cls):
    """
    Decorator for attaching a logger to the class `cls`

    Loggers inherit the syntax {module}.{submodule}

    Example
        >>> @log
        ... class MyClass(object):
        ...     pass
        >>>
        >>> myclass = MyClass()
        >>> myclass.log.info('Hello World')
    """
    ...


def plugin_paths():
    """
    Collect paths from all sources.

    This function looks at the three potential sources of paths
    and returns a list with all of them together.

    The sources are:

    - Registered paths using :func:`register_plugin_path`,
    - Paths from the environment variable `PYBLISHPLUGINPATH`

    Returns:
        list of paths in which plugins may be locat
    """
    ...


def plugins_by_family(plugins, family):
    """
    Convenience function to :func:`plugins_by_families`

    Arguments:
        plugins (list): List of plugins
        family (str): Family with which to compare against

    Returns:
        List of compatible plugins.
    """
    ...


def plugins_by_host(plugins, host):
    """
    Return compatible plugins `plugins` to host `host`

    Arguments:
        plugins (list): List of plugins
        host (str): Host with which compatible plugins are returned

    Returns:
        List of compatible plugins.
    """
    ...


def plugins_by_instance(plugins, instance):
    """
    Conveinence function for :func:`plugins_by_family`

    Arguments:
        plugins (list): Plug-ins to assess
        instance (Instance): Instance with which to compare against

    Returns:
        List of compatible plugins
    """
    ...


def plugins_by_targets(plugins, targets):
    """
    Reutrn compatible plugins `plugins` to targets `targets`

    Arguments:
        plugins (list): List of plugins
        targets (list): List of targets with which to compare against

    Returns:
        List of compatible plugins.
    """
    ...


def register_callback(signal, callback):
    """
    Register a new callback

    Arguments:
        signal (string): Name of signal to register the callback with.
        callback (func): Function to execute when a signal is emitted.

    Raises:
        ValueError if `callback` is not callable.
    """
    ...


def register_discovery_filter(callback):
    """
    Register a new plugin filter

    Arguments:
        callback (func): Function to execute on filter during discovery,
            takes the original of plugins to be edited in-place

    Raises:
        ValueError if `callback` is not callable.
    """
    ...


def register_gui(package):
    """
    Register a default GUI for Pyblish

    The argument `package` must refer to an available Python
    package with access to a `.show` member function taking no
    arguments. E.g.

    def show():
        pass

    This function is called whenever the default GUI
    is activated.

    Multiple GUIs:
        You may register more than one GUI, in which case each
        is tried in turn until a functioning match is found.

        For example, if both Pyblish QML and Pyblish Lite are
        registered, but Pyblish QML is not installed, then
        Pyblish Lite would appear as a "fallback".

    Arguments:
        package (str): Name of Python package with .show function.
    """
    ...


def register_host(host):
    """
    Register a new host

    Registered hosts are used to filter discovered
    plug-ins by host.

    Example:
        >>> register_host("My Host")
        >>> "My Host" in registered_hosts()
        True
    """
    ...


def register_plugin(plugin):
    """
    Register a new plug-in

    Arguments:
        plugin (Plugin): Plug-in to register

    Raises:
        TypeError if `plugin` is not callable
    """
    ...


def register_plugin_path(path):
    """
    Plug-ins are looked up at run-time from directories registered here

    To register a new directory, run this command along with the absolute
    path to where you"re plug-ins are located.

    Example:
        >>> import os
        >>> my_plugins = os.path.join("server", "plugins")
        >>> register_plugin_path(my_plugins) == os.path.normpath(my_plugins)
        True

    Returns:
        Actual path added, including any post-processing
    """
    ...


def register_service(*args, **kwargs):
    """
    Register a new service

    Arguments:
        name (str): Name of service
        obj (any): Any object
    """
    ...


def register_target(target):
    """
    Register a new target

    Registered targets can be used in plug-ins to determin outputs

    Example:
        >>> register_target("Studio")
        >>> "Studio" in registered_targets()
        True
        >>> current_target()
        'Studio'
    """
    ...


def register_test(test):
    """
    Register test used to determine when to abort processing

    Arguments:
        test (callable): Called with argument `vars` and returns
            either True or False. True means to continue,
            False to abort.

    Example:
        >>> # Register custom test
        >>> def my_test(**vars):
        ...   return 1
        ...
        >>> register_test(my_test)
        >>>
        >>> # Run test
        >>> if my_test(order=1, ordersWithError=[]):
        ...   print("Test passed")
        Test passed
        >>>
        >>> # Restore default
        >>> deregister_test()
    """
    ...


def registered_callbacks():
    """
    Returns registered callbacks
    """
    ...


def registered_discovery_filters():
    """
    Returns registered plugin filter callbacks
    """
    ...


def registered_guis():
    """
    Return registered GUIs
    """
    ...


def registered_hosts():
    """
    Return the currently registered hosts
    """
    ...


def registered_paths():
    """
    Return paths added via registration

    ..note:: This returns a copy of the registered paths
        and can therefore not be modified directly.
    """
    ...


def registered_plugins():
    """
    Return plug-ins added via :func:`register_plugin`

    .. note:: This returns a copy of the registered plug-ins
        and can therefore not be modified directly
    """
    ...


def registered_services(*args, **kwargs):
    """
    Return the currently registered services as a dictionary

    .. note:: This returns a copy of the registered paths
        and can therefore not be modified directly.
    """
    ...


def registered_targets():
    """
    Return the currently registered targets
    """
    ...


def registered_test():
    """
    Return the currently registered test
    """
    ...


def sort(*args, **kwargs):
    """
    """
    ...


sort_plugins = sort

CollectorOrder: int = 0

Exact: int = 4

ExtractorOrder: int = 2

IntegratorOrder: int = 3

Intersection: int = 1

Subset: int = 2

ValidatorOrder: int = 1

__all__: ...
"""
['Action', 'Asset', 'Category', 'Collector', 'CollectorOrder...
"""

absolute_import: ...
"""
_Feature((2, 5, 0, 'alpha', 1), (2, 7, 0, 'alpha', 0...
"""

version: six.binary_type
"""
'1.8.8'
"""

