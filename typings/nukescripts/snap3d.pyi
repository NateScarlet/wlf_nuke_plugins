"""
This type stub file was generated by pyright.
"""

def translateThisNodeToPoints(): ...
def translateRotateThisNodeToPoints(): ...
def translateRotateScaleThisNodeToPoints(): ...
def translateToPoints(nodeToSnap):
    """
    Translate the specified node to the average position of the current vertex selection in the active viewer.
    The nodeToSnap must contain a 'translate' knob and the transform order must be 'SRT'.

    @type nodeToSnap:   nuke.Node
    @param nodeToSnap:  Node to translate
    """
    ...

def translateRotateToPoints(nodeToSnap):
    """
    Translate the specified node to the average position of the current vertex selection in the active viewer
    and rotate to the orientation of the (mean squares) best fit plane for the selection.
    The nodeToSnap must contain 'translate' and 'rotate' knobs, the transform order must be 'SRT' and the
    rotation order must be 'ZXY'.

    @type nodeToSnap:   nuke.Node
    @param nodeToSnap:  Node to translate and rotate
    """
    ...

def translateRotateScaleToPoints(nodeToSnap):
    """
    Translate the specified node to the average position of the current vertex selection in the active viewer,
    rotate to the orientation of the (mean squares) best fit plane for the selection
    and scale to the extents of the selection.
    The nodeToSnap must contain 'translate', 'rotate' and 'scale' knobs, the transform order must be 'SRT' and
    the rotation order must be 'ZXY'.

    @type nodeToSnap:   nuke.Node
    @param nodeToSnap:  Node to translate, rotate and scale
    """
    ...

def translateSelectionToPoints(nodeToSnap, vertexSelection): ...
def translateRotateSelectionToPoints(nodeToSnap, vertexSelection): ...
def translateRotateScaleSelectionToPoints(nodeToSnap, vertexSelection): ...
def verifyVertexSelection(vertexSelection, minLen): ...
def verifyNodeToSnap(nodeToSnap, knobList): ...
def verifyNodeOrder(node, knobName, orderName): ...

class VertexInfo:
    def __init__(self, objnum, index, value, position) -> None: ...

class VertexSelection:
    def __init__(self) -> None: ...
    def __len__(self): ...
    def __iter__(self): ...
    def add(self, vertexInfo): ...
    def points(self): ...
    def indices(self): ...
    def translate(self, vector): ...
    def inverseRotate(self, vector, order): ...
    def scale(self, vector): ...

def transpose(m): ...
def translateToPointsVerified(nodeToSnap, vertexSelection): ...
def scaleToPointsVerified(nodeToScale, vertexSelection): ...
def rotateToPointsVerified(nodeToSnap, vertexSelection): ...
def translateRotateToPointsVerified(nodeToSnap, vertexSelection): ...
def translateRotateScaleToPointsVerified(nodeToSnap, vertexSelection): ...
def calcRotationVector(vertexSelection, norm): ...
def calcAveragePosition(vertexSelection):
    """
    Calculate the average position of all points.

    @param points: An iterable sequence of _nukemath.Vector3 objects.
    @return: A _nukemath.Vector3 containing the average of all the points.
    """
    ...

def calcBounds(vertexSelection): ...
def planeRotation(tri, norm=...):
    """
    Calculate the rotations around the X, Y and Z axes that will align a plane
    perpendicular to the Z axis with the given triangle.

    @param tri: A list or tuple of 3 _nukemath.Vector3 objects. The 3 points must
     describe the plane (i.e. they must not be collinear).
    @return: A _nukemath.Vector3 object where the x coordinate is the angle of
     rotation around the x axis and so on.
    @raise ValueError: if the three points are collinear.
    """
    ...

def averageNormal(vertexSelection):
    """
    averageNormal(selectionThreshold -> _nukemath.Vector3
    Return a _nukemath.Vector3 which is the average of the normals of all selected points
    """
    ...

def anySelectedPoint(selectionThreshold=...):
    """
    anySelectedPoint(selectionThreshold) -> _nukemath.Vector3
    Return a selected point from the active viewer or the first viewer with a selection.
    The selectionThreshold parameter is used when working with a soft selection.
    Only points with a selection level >= the selection threshold will be returned by this function.
    """
    ...

def selectedPoints(selectionThreshold=...):
    """
    selectedPoints(selectionThreshold) -> iterator

    Return an iterator which yields the position of every point currently
    selected in the Viewer in turn.

    The selectionThreshold parameter is used when working with a soft selection.
    Only points with a selection level >= the selection threshold will be
    returned by this function.
    """
    ...

def getSelection(selectionThreshold=...): ...
def selectedVertexInfos(selectionThreshold=...):
    """
    selectedVertexInfos(selectionThreshold) -> iterator

    Return an iterator which yields a tuple of the index and position of each
    point currently selected in the Viewer in turn.

    The selectionThreshold parameter is used when working with a soft selection.
    Only points with a selection level >= the selection threshold will be
    returned by this function.
    """
    ...

def anySelectedVertexInfo(selectionThreshold=...):
    """
    anySelectedVertexInfo(selectionThreshold) -> VertexInfo

    Returns a single VertexInfo for a selected point. If more than one point is
    selected, one of them will be chosen arbitrarily.

    The selectionThreshold parameter is used when working with a soft selection.
    Only points with a selection level >= the selection threshold will be
    returned by this function.
    """
    ...

def allNodes(node=...):
    """
    allNodes() -> iterator
    Return an iterator which yields all nodes in the current script.

    This includes nodes inside groups. They will be returned in top-down,
    depth-first order.
    """
    ...

def allNodesWithGeoSelectKnob(): ...
def cameraProjectionMatrix(cameraNode):
    "Calculate the projection matrix for the camera based on its knob values."
    ...

def projectPoints(camera=..., points=...):
    """
    projectPoint(camera, points) -> list of nuke.math.Vector2

    Project the given 3D point through the camera to get 2D pixel coordinates.

    @param camera: The Camera node or name of the Camera node to use for projecting
                   the point.
    @param points: A list or tuple of either nuke.math.Vector3 or of list/tuples of
                   three float values representing the 3D points.
    @raise ValueError: If camera or point is invalid.
    """
    ...

def projectPoint(camera=..., point=...):
    """
    projectPoint(camera, point) -> nuke.math.Vector2

    Project the given 3D point through the camera to get 2D pixel coordinates.

    @param camera: The Camera node or name of the Camera node to use for projecting
                   the point.
    @param point: A nuke.math.Vector3 or of list/tuple of three float values
                  representing the 3D point.
    @raise ValueError: If camera or point is invalid.
    """
    ...

def projectSelectedPoints(cameraName=...):
    """
    projectSelectedPoints(cameraName='Camera1') -> iterator yielding nuke.math.Vector2

    Using the specified camera, project all of the selected points into 2D pixel
    coordinates and return their locations.

    @param cameraName: Optional name of the Camera node to use for projecting the
                       points. If omitted, will look for a node called Camera1.
    """
    ...

snapFuncs = []

def addSnapFunc(label, func):
    """
    addSnapFunc(label, func) -> None
    Add a new snapping function to the list.

    The label parameter is the text that will appear in (eg.) an Enumeration_Knob
    for the function. It cannot be the same as any existing snap function label
    (if it is, the function will abort without changing anything).

    The func parameter is the snapping function. It must be a callable object
    taking a single parameter: the node to perform the snapping on.
    """
    ...

def callSnapFunc(nodeToSnap=...):
    """
    callSnapFunc(nodeToSnap) -> None
    Call the snapping function on a node.

    The nodeToSnap parameter is optional. If it's not specified, or is None, we
    use the result of nuke.thisNode() instead.

    The node must have an Enumeration_Knob called "snapFunc" which selects the
    snapping function to call.
    """
    ...
